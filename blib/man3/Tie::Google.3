.\" Automatically generated by Pod::Man version 1.15
.\" Fri Feb 14 09:54:36 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Google 3"
.TH Google 3 "perl v5.6.1" "2003-02-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Tie::Google \- Single-variable access to Google search results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  my $KEYFILE = glob "~/.googlekey";
\&  my ($g, @g, %g);
.Ve
.Vb 6
\&  # Tied array interface
\&  tie @g, "Tie::Google", $KEYFILE, "perl";
\&  for my $r (@g) {
\&      printf " * <a href='%s'>%s</a>\en",
\&          $r->{'URL'}, $r->{'title'};
\&  }
.Ve
.Vb 5
\&  # Tied hash interface
\&  tie %g, "Tie::Google", $KEYFILE;
\&  for my $term (qw[ perl python ruby ]) {
\&      my $res = $g{$term};
\&      printf "%d results for '%s:\en", scalar @$res, $term;
.Ve
.Vb 5
\&      for my $r (@$res) {
\&          printf " * <a href='%s'>%s</a>\en",
\&              $r->{'URL'}, $r->{'title'};
\&      }
\&  }
.Ve
.Vb 4
\&  # Tied scalar interface: I Feel Lucky
\&  use LWP::Simple qw(getprint);
\&  tie $g, "Tie::Google", $KEYFILE, "perl";
\&  getprint($g->{'URL'});
.Ve
.SH "USING Tie::Google"
.IX Header "USING Tie::Google"
Using tied variables can make searching Google much simpler for
trivial programs.  \f(CW\*(C`Tie::Google\*(C'\fR presents a simple interface to
Google's search \s-1API\s0, using \f(CW\*(C`Net::Google\*(C'\fR as the underlying transport
mechanism.  To use \f(CW\*(C`Tie::Google\*(C'\fR, you must already be registered with
Google and have an \s-1API\s0 key.
.PP
You can tie scalars, arrays, or hashes to the \f(CW\*(C`Tie::Google\*(C'\fR class;
each offers slightly different functionality, but all offer direct
access to Google search results.  The basic syntax of all types is:
.PP
.Vb 1
\&  tie VAR, 'Tie::Google', $APIKEY, $QUERY, \e%OPTIONS;
.Ve
where:
.Ip "\s-1VAR\s0" 8
.IX Item "VAR"
\&\s-1VAR\s0 is the variable name, which can be a scalar, array, or hash:
.Sp
.Vb 3
\&  tie $g, "Tie::Google", $KEY, $term;
\&  tie @g, "Tie::Google", $KEY, $term;
\&  tie %g, "Tie::Google", $KEY, $term;
.Ve
.Ip "$APIKEY" 8
.IX Item "$APIKEY"
\&\s-1APIKEY\s0 is your Google \s-1API\s0 key or a file containing the key as the only
item on the first line; see
http://apis.google.com for details.
.Ip "$QUERY" 8
.IX Item "$QUERY"
\&\s-1QUERY\s0 is your actual search \fIterm\fR\|(s), as a string.  This can be
arbitrarily complex, up to the limits Google allows:
.Sp
.Vb 2
\&  tie $g, "Tie::Google", $KEY,
\&    "site:cnn.com allintitle:priest court -judas";
.Ve
.Ip "%OPTIONS" 8
.IX Item "%OPTIONS"
Any options specified in this hashref will be passed to the
Net::Google::Search instance.  Available options include \f(CW\*(C`starts_at\*(C'\fR,
\&\f(CW\*(C`max_results\*(C'\fR, \f(CW\*(C`ie\*(C'\fR, \f(CW\*(C`oe\*(C'\fR, and \f(CW\*(C`lr\*(C'\fR.  See the Net::Google manpage.
.Sh "The Tied Array Interface"
.IX Subsection "The Tied Array Interface"
Tieing an array to \f(CW\*(C`Tie::Google\*(C'\fR gives you an array of search
results.  How many search results are returned depends on the value of
the \f(CW\*(C`max_results\*(C'\fR option defined when the array was tied (or
\&\f(CW$DEFAULT_BATCH_SIZE\fR if \f(CW\*(C`max_results\*(C'\fR was not set), though extending
the array of results can be done by growing the array.
.PP
.Vb 1
\&  #$g = 20;
.Ve
Will resize the result set to 20 results.  If there are more than 20,
the ones on the end will be popped off; if there are less than 20,
then more will be retrieved.
.PP
\&\f(CW\*(C`Tie::Google\*(C'\fR supports all non-additive array operations, including
\&\f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, and the 3 argument form of \f(CW\*(C`splice\*(C'\fR (not the 4
argument version).  Specifically unallowed are \f(CW\*(C`unshift\*(C'\fR, \f(CW\*(C`push\*(C'\fR,
and general assigment.
.PP
See the section on "RESULTS" for details about the individual search results.
.Sh "The Tied Hash Interface"
.IX Subsection "The Tied Hash Interface"
The tied hash interface is similar to the tied array interface, except
that there are a bunch of them.  Asking for a key in the hash \f(CW%g\fR
initiates a search to Google, with the specified key as the search
term:
.PP
.Vb 1
\&  my $results = $g{'perl apache'};
.Ve
This initiates a search with \*(L"perl apache\*(R" as the query.  \f(CW$results\fR is
a reference to an array of hashrefs (see the section on "RESULTS" for details
about said hashrefs).
.PP
Tied hashes support all hash functions, including \f(CW\*(C`each\*(C'\fR, \f(CW\*(C`keys\*(C'\fR,
and \f(CW\*(C`values\*(C'\fR.  Deleting from the hash is allowed (it removes the
search results for the deleted terms), but adding to the hash is not.
.PP
There can be many sets of search results stored in a tied hash.  To
see what this looks like, try this:
.PP
.Vb 2
\&  use Data::Dumper;
\&  my (%g, $KEY, $dummy);
.Ve
.Vb 4
\&  tie %g, "Tie::Google", $KEY;
\&  $dummy = $g{'perl'};
\&  $dummy = $g{'python'};
\&  $dummy = $g{'ruby'};
.Ve
.Vb 1
\&  print Dumper(tied(%g));
.Ve
Also, for comparison, try:
.PP
.Vb 2
\&  tie @g, "Tie::Google", $KEY, "perl";
\&  print Dumper(tied(@g));
.Ve
If \f(CW\*(C`starts_at\*(C'\fR or \f(CW\*(C`max_results\*(C'\fR are specified during the \f(CW\*(C`tie\*(C'\fR,
these options are carried over into new searches (when a new key is
requested from the hash), so plan accordingly.  If the \f(CW\*(C`max_value\*(C'\fR is
set to 1000, for example, then every access of a new key is going to
contain 1000 elements, which will be pretty slow.
.Sh "The Tied Scalar Interface"
.IX Subsection "The Tied Scalar Interface"
Do you feel lucky?  If so, tie a scalar to \f(CW\*(C`Tie::Google\*(C'\fR:
.PP
.Vb 1
\&  tie $g, "Tie::Google", $KEY, "python";
.Ve
Will give you the top result.  This is conceptually similar to using
the \*(L"I Feel Lucky\*(R" button on Google.com's front search interface.
.SH "RESULTS"
.IX Header "RESULTS"
All results (values returned from these tied variables) are hash
references; the contents of these hashrefs are based on the
\&\f(CW\*(C`Net::Google::Response\*(C'\fR class (see the Net::Google::Response manpage for
details).  These elements currently are:
.Ip "\(bu" 4
title
.Ip "\(bu" 4
\&\s-1URL\s0
.Ip "\(bu" 4
snippet
.Ip "\(bu" 4
cachedSize
.Ip "\(bu" 4
directoryTitle
.Ip "\(bu" 4
summary
.Ip "\(bu" 4
hostName
.Ip "\(bu" 4
directoryCategory
.PP
All keys are case sensitive, and return exactly what
the Net::Google::Response manpage says they do (\f(CW\*(C`Tie::Google\*(C'\fR does no
massaging of this data).
.SH "TODO / BUGS"
.IX Header "TODO / BUGS"
This module is far from complete, or even fully thought out.  \s-1TODO\s0
items currently include:
.Ip "\(bu" 4
The tests currently suck, to the point of embarrassment.  Don't
mention it, I'm a little sensitive about it.
.Ip "\(bu" 4
Some of the behaviors are kind of wonky.  If anyone has any better
ideas, please let me know.  Patches demanded^Wwelcome^.
.Ip "\(bu" 4
Tied arrays should get the next 10 results when you get to the end of
the array.  Currently, you have to manually extend the array using:
.Sp
.Vb 1
\&  $#g = 100;
.Ve
to get 100 search results.
.Sp
Although this technique will have the unfortunate side-effect of
trying to iterate through all the results in Google's database.
.Ip "\(bu" 4
The tied hash interface should be implemented in terms of the tied
array interface.  That is, the values associated with each key (search
term) should be a reference to an array tied to \f(CW\*(C`Tie::Google\*(C'\fR.  I
started doing it this way but it made my brain hurt.
.Ip "\(bu" 4
Does there need to be a \s-1TIEHANDLE\s0 interface as well?  Hmmm...
.Sp
.Vb 2
\&  while (<$google>) {
\&      ...
.Ve
.Ip "\(bu" 4
Should returned search results be data structures (they are
currently), the actual \f(CW\*(C`Net::Google::Result\*(C'\fR instances (where the
data is currently being derived from), or new objects in their own
right (e.g., \f(CW\*(C`Tie::Google::Result\*(C'\fR)?  I see advantages to each path:
data structures would be simpler, passing on \f(CW\*(C`Result\*(C'\fR objects without
modification would be faster, and using a new set of objects allows
new functionality to be added, for example useful stringification.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the Net::Google manpage, the DBD::google manpage
.SH "AUTHOR"
.IX Header "AUTHOR"
darren chamberlain (<darren@cpan.org>), with some prompting
from Richard Soderberg.
